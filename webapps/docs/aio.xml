<?xml version="1.0"?>
<!--
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<!DOCTYPE document [
  <!ENTITY project SYSTEM "project.xml">
]>
<document url="aio.html">

    &project;

  <properties>
    <title>고급 IO와 톰캣</title>
    <author>레미 모체랏</author>
  </properties>

<body>

<section name="Table of Contents">
<toc/>
</section>

  <section name="Introduction">

  <p>
    APR 또는 NIO API를 커넥터의 기반으로 사용할 때, 톰캣은 서블릿 API를 지원하는데 제공되는 
    일반적인 블로킹 IO 위에서 수많은 확장을 제공할 수 있다.
  </p>

  <p>
    <b>중요 노트: 이 기능을 이용하려면 APR 또는 NIO HTTP커넥터를 사용해야 합니다.
    클래식 java.io HTTP 커넥터와 AJP 커넥터는 지원되지 않습니다.</b>
  </p>

  </section>

  <section name="Comet support">

  <p>
    Comet 지원은 서블릿에서 비동기적으로 IO 처리를 가능하게 하고, 연결된 상태에서 
  데이터를 읽기가 가능한 경우에 (블로킹 읽기를 항상 사용하는 대신에)이벤트를 
    받고, 비동기적으로 연결 상에서 데이터를 써서 보낼 수 있게 합니다(대부분 어떤 
    다른 소스에서 발생한 어떤 이벤트에 응답하는 형태).
  </p>

  <subsection name="CometEvent">

  <p>
    <code>org.apache.catalina.comet.CometProcessor</code> 인터페이스를 구현한 서블릿은
    일반적인 서비스 메소드가 아닌, 발생한 이벤트에 따라 해당되는 이벤트 메소드를 호출하게 됩니다.
    이벤트 객체는 일반적인 요청과 응답 객체에 접근할 수 있어서, 일반적인 방법으로도 사용할 수 있게
    합니다. 중요한 차이점은 이 객체들은 END 또는 ERROR 이벤트 처리를 할 때까지 BEGIN 이벤트
    처리 사이에서 유효하고 모든 기능을 다 사용할 수 있는 상태로 남아있게 됩니다.
    다음은 이벤트 타입입니다:
  </p>

  <ul>
  <li>EventType.BEGIN: 연결 처리의 시작에 호출됩니다.
     요청과 응답 객체를 사용하는 연관된 필드를 초기화하는데 사용됩니다. 
     이 이벤트의 처리 마지막과 종료 또는 에러 이벤트 처리의 시작 사이에서, 
     열려있는 연결에 응답 객체를 사용해서 데이터를 보내는 것이 가능합니다.
     응답 객체와 의존적인 OutputStream과 Writer는 여전히 동기화되지 않기 때문에,
     멀티 쓰레드에서 접근될 때는 동기화는 절대적입니다. 초기 이벤트를 처리한 뒤,
     요청은 커밋된 것으로 간주됩니다.</li>
  <li>EventType.READ: This indicates that input data is available, and that one read can be made
       without blocking. The available and ready methods of the InputStream or
       Reader may be used to determine if there is a risk of blocking: the servlet
       should read while data is reported available. When encountering a read error,
       the servlet should report it by propagating the exception properly. Throwing
       an exception will cause the error event to be invoked, and the connection
       will be closed.
       Alternately, it is also possible to catch any exception, perform clean up
       on any data structure the servlet may be using, and using the close method
       of the event. It is not allowed to attempt reading data from the request
       object outside of the execution of this method.<br/>
       On some platforms, like Windows, a client disconnect is indicated by a READ event.
       Reading from the stream may result in -1, an IOException or an EOFException.
       Make sure you properly handle all these three cases.
       If you don't catch the IOException, Tomcat will instantly invoke your event chain with an ERROR as
       it catches the error for you, and you will be notified of the error at that time.
  </li>
  <li>EventType.END: End may be called to end the processing of the request. Fields that have
     been initialized in the begin method should be reset. After this event has
     been processed, the request and response objects, as well as all their dependent
     objects will be recycled and used to process other requests. End will also be
     called when data is available and the end of file is reached on the request input
     (this usually indicates the client has pipelined a request).</li>
  <li>EventType.ERROR: Error will be called by the container in the case where an IO exception
     or a similar unrecoverable error occurs on the connection. Fields that have
     been initialized in the begin method should be reset. After this event has
     been processed, the request and response objects, as well as all their dependent
     objects will be recycled and used to process other requests.</li>
  </ul>

  <p>
    There are some event subtypes which allow finer processing of events (note: some of these
    events require usage of the org.apache.catalina.valves.CometConnectionManagerValve valve):
  </p>

  <ul>
  <li>EventSubType.TIMEOUT: The connection timed out (sub type of ERROR); note that this ERROR
    type is not fatal, and the connection will not be closed unless the servlet uses the close
    method of the event.
  </li>
  <li>EventSubType.CLIENT_DISCONNECT: The client connection was closed (sub type of ERROR).
  </li>
  <li>EventSubType.IOEXCEPTION: An IO exception occurred, such as invalid content, for example,
    an invalid chunk block (sub type of ERROR).
  </li>
  <li>EventSubType.WEBAPP_RELOAD: The web application is being reloaded (sub type of END).
  </li>
  <li>EventSubType.SESSION_END: The servlet ended the session (sub type of END).
  </li>
  </ul>

  <p>
    As described above, the typical lifecycle of a Comet request will consist in a series of
    events such as: BEGIN -> READ -> READ -> READ -> ERROR/TIMEOUT. At any time, the servlet
    may end processing of the request by using the close method of the event object.
  </p>

  </subsection>

  <subsection name="CometFilter">

  <p>
    Similar to regular filters, a filter chain is invoked when comet events are processed.
    These filters should implement the CometFilter interface (which works in the same way as
    the regular Filter interface), and should be declared and mapped in the deployment
    descriptor in the same way as a regular filter. The filter chain when processing an event
    will only include filters which match all the usual mapping rules, and also implement
    the CometFiler interface.
  </p>

  </subsection>

  <subsection name="Example code">

  <p>
    The following pseudo code servlet implements asynchronous chat functionality using the API
    described above:
  </p>

  <source>
public class ChatServlet
    extends HttpServlet implements CometProcessor {

    protected ArrayList&lt;HttpServletResponse> connections =
        new ArrayList&lt;HttpServletResponse>();
    protected MessageSender messageSender = null;

    public void init() throws ServletException {
        messageSender = new MessageSender();
        Thread messageSenderThread =
            new Thread(messageSender, "MessageSender[" + getServletContext().getContextPath() + "]");
        messageSenderThread.setDaemon(true);
        messageSenderThread.start();
    }

    public void destroy() {
        connections.clear();
        messageSender.stop();
        messageSender = null;
    }

    /**
     * Process the given Comet event.
     *
     * @param event The Comet event that will be processed
     * @throws IOException
     * @throws ServletException
     */
    public void event(CometEvent event)
        throws IOException, ServletException {
        HttpServletRequest request = event.getHttpServletRequest();
        HttpServletResponse response = event.getHttpServletResponse();
        if (event.getEventType() == CometEvent.EventType.BEGIN) {
            log("Begin for session: " + request.getSession(true).getId());
            PrintWriter writer = response.getWriter();
            writer.println("&lt;!doctype html public \"-//w3c//dtd html 4.0 transitional//en\">");
            writer.println("&lt;head>&lt;title>JSP Chat&lt;/title>&lt;/head>&lt;body bgcolor=\"#FFFFFF\">");
            writer.flush();
            synchronized(connections) {
                connections.add(response);
            }
        } else if (event.getEventType() == CometEvent.EventType.ERROR) {
            log("Error for session: " + request.getSession(true).getId());
            synchronized(connections) {
                connections.remove(response);
            }
            event.close();
        } else if (event.getEventType() == CometEvent.EventType.END) {
            log("End for session: " + request.getSession(true).getId());
            synchronized(connections) {
                connections.remove(response);
            }
            PrintWriter writer = response.getWriter();
            writer.println("&lt;/body>&lt;/html>");
            event.close();
        } else if (event.getEventType() == CometEvent.EventType.READ) {
            InputStream is = request.getInputStream();
            byte[] buf = new byte[512];
            do {
                int n = is.read(buf); //can throw an IOException
                if (n &gt; 0) {
                    log("Read " + n + " bytes: " + new String(buf, 0, n)
                            + " for session: " + request.getSession(true).getId());
                } else if (n &lt; 0) {
                    error(event, request, response);
                    return;
                }
            } while (is.available() > 0);
        }
    }

    public class MessageSender implements Runnable {

        protected boolean running = true;
        protected ArrayList&lt;String> messages = new ArrayList&lt;String>();

        public MessageSender() {
        }

        public void stop() {
            running = false;
        }

        /**
         * Add message for sending.
         */
        public void send(String user, String message) {
            synchronized (messages) {
                messages.add("[" + user + "]: " + message);
                messages.notify();
            }
        }

        public void run() {

            while (running) {

                if (messages.size() == 0) {
                    try {
                        synchronized (messages) {
                            messages.wait();
                        }
                    } catch (InterruptedException e) {
                        // Ignore
                    }
                }

                synchronized (connections) {
                    String[] pendingMessages = null;
                    synchronized (messages) {
                        pendingMessages = messages.toArray(new String[0]);
                        messages.clear();
                    }
                    // Send any pending message on all the open connections
                    for (int i = 0; i &lt; connections.size(); i++) {
                        try {
                            PrintWriter writer = connections.get(i).getWriter();
                            for (int j = 0; j &lt; pendingMessages.length; j++) {
                                writer.println(pendingMessages[j] + "&lt;br>");
                            }
                            writer.flush();
                        } catch (IOException e) {
                            log("IOExeption sending message", e);
                        }
                    }
                }

            }

        }

    }

}
  </source>

  </subsection>
  <subsection name="Comet timeouts">
    <p>If you are using the NIO connector, you can set individual timeouts for your different comet connections.
       To set a timeout, simply set a request attribute like the following code shows:
       <source>CometEvent event.... event.setTimeout(30*1000);</source> or
       <source>event.getHttpServletRequest().setAttribute("org.apache.tomcat.comet.timeout", new Integer(30 * 1000));</source>
       This sets the timeout to 30 seconds.
       Important note: in order to set this timeout, it has to be done on the <code>BEGIN</code> event.
       The default value is <code>soTimeout</code>
    </p>
    <p>If you are using the APR connector, all Comet connections will have the same timeout value. It is <code>soTimeout*50</code>
    </p>
  </subsection>

  </section>

  <section name="Asynchronous writes">

  <p>
    When APR or NIO is enabled, Tomcat supports using sendfile to send large static files.
    These writes, as soon as the system load increases, will be performed
    asynchronously in the most efficient way. Instead of sending a large response using
    blocking writes, it is possible to write content to a static file, and write it
    using a sendfile code. A caching valve could take advantage of this to cache the
    response data in a file rather than store it in memory. Sendfile support is
    available if the request attribute <code>org.apache.tomcat.sendfile.support</code>
    is set to <code>Boolean.TRUE</code>.
  </p>

  <p>
    Any servlet can instruct Tomcat to perform a sendfile call by setting the appropriate
    request attributes. It is also necessary to correctly set the content length
    for the response. When using sendfile, it is best to ensure that neither the
    request or response have been wrapped, since as the response body will be sent later
    by the connector itself, it cannot be filtered. Other than setting the 3 needed
    request attributes, the servlet should not send any response data, but it may use
    any method which will result in modifying the response header (like setting cookies).
  </p>

  <ul>
  <li><code>org.apache.tomcat.sendfile.filename</code>: Canonical filename of the file which will be sent as
      a String</li>
  <li><code>org.apache.tomcat.sendfile.start</code>: Start offset as a Long</li>
  <li><code>org.apache.tomcat.sendfile.end</code>: End offset as a Long</li>
  </ul>

  </section>

</body>
</document>
