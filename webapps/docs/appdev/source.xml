<?xml version="1.0"?>
<!--
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<!DOCTYPE document [
  <!ENTITY project SYSTEM "project.xml">
]>
<document url="source.html">

  &project;

  <properties>
    <author email="craigmcc@apache.org">크레이그 R. 맥클라나한</author>
    <title>원본 구조</title>
  </properties>

<body>

<section name="Table of Contents">
<toc/>
</section>

<section name="Directory Structure">

    <blockquote><em>
    <p>다음 설명은 대부분의 상대 경로가 해결되고 그에 대한 기본 디렉토리를 참조하는 변수 이름을 $ CATALINA_BASE를 사용하고 있습니다.
    당신은 CATALINA_BASE를 설정하여 여러 인스턴스에 Tomcat을 구성하지 않은 경우, 디렉토리의 다음 $ CATALINA_BASE는 $ CATALINA_HOME의 값으로 설정됩니다.
    Tomcat을 설치 한 디렉터리입니다.</p>
    </em></blockquote>

<p>이 설명서의 주요 권고 사항은 배포 응용 프로그램 (앞에서 설명한)를 포함하는 디렉토리 계층 구조에서 소스 코드를 (이 절에서 설명)를 포함하는 디렉토리 계층을 분리하는 것입니다.
이 분리를 유지하는 것은 다음과 같은 장점이 있습니다.</p>
<ul>
<li>소스 디렉토리의 내용을 보다 쉽게 관리 할 수 있는 이동, "실행 가능한" 응용 프로그램 버전이 혼합되지 않은 경우 백업할 수 있습니다.
    <br/><br/></li>
<li>소스 코드 관리, 소스 파일이 있는 디렉토리의 관리가 용이합니다.
    <br/><br/></li>
<li>응용 프로그램 설치 가능한 배포판을 구성하는 파일은 배포 계층이 다른 때 선택하는 것이 훨씬 쉽습니다.</li>
</ul>

<p>우리가 본대로, <code> ant </ code> 의 개발 도구는 이러한 디렉터리 계층 생성 및 처리가 거의 고통에 가깝습니다.</p>

<p>응용 프로그램의 소스 코드를 저장하는 데 사용되는 실제 디렉터리 및 파일 계층이 좋지만은 않다는 것입니다.
그러나 다음의 조직은 매우 일반적으로 적용 가능한 것으로 판명되어, 예를 들면 이 <code> build.xml </ code> 가 아래에 설명된 구성 파일이 됩니다.
이러한 모든 구성 요소는 응용 프로그램의 최상위 <em> 프로젝트 소스 디렉토리 </em> 아래에 있습니다.:</p>
<ul>
<li><strong>docs/</strong> - 응용 프로그램 설명서는 어떤 형식으로 개발팀이 사용하고 있습니다.<br/><br/></li>
<li><strong>src/</strong> - Java 소스 서블릿, Bean 및 응용 프로그램 별 다른 Java 클래스를 생성한 파일입니다.
    당신의 소스 코드 패키지가 (<strong> highly </strong> 권장) 로 구성되어있는 경우, 패키지 계층이 디렉토리 아래에 디렉토리 구조에 반영되어야 합니다.<br/><br/></li>
<li><strong>web/</strong> - Web 사이트의 정적 콘텐츠는 (HTML 페이지, JSP 페이지, Java 스크립트 파일, CSS 스타일 시트 파일, 이미지), 응용 프로그램 클라이언트에 액세스 할 수 있습니다.
이 디렉토리는 <EM> 문서 루트 </em>는 Web 응용 프로그램 및 모든 하위 디렉토리 구조는 URI가 해당 파일에 액세스하는 데 필요한 요구에도 반영됩니다.<br/><br/></li>
<li><strong>web/WEB-INF/</strong> - Web 응용 프로그램 배포 설명자 (같은 응용 프로그램에 필요한 특수 설정 파일 <code> web.xml </code> 는 <a href = "http://wiki.apache.org/tomcat/Specifications"> 서블릿 사양 </a>, 커스텀 태그 라이브러리 및 당신의 Web 응용 프로그램에 포함할 다른 리소스 파일의 태그 라이브러리 디스크립터입니다.
이 디렉토리는 <EM> 문서 루트의 하위 디렉토리인 것으로 보임에도 불구하고 </em>는 서블릿 사양 클라이언트 요청에 직접이 디렉토리의 내용 (또는 여기에 포함된 모든 파일) 의 이동을 금지합니다.
따라서 이것은 (데이터베이스 연결 아이디와 비밀번호 등)의 영향을 받기 쉽고, 구성 정보를 저장하기에 좋은 장소입니다. 또한, 성공적으로 실행되는 응용 프로그램에 필요합니다.</li>
</ul>

<p>프로그램이 개발되고 있는 동안에 두 추가 디렉토리가 일시적으로 생성됩니다.:</p>
<ul>
<li><strong>build/</strong> - 기본을 실행하면 빌드 (<code> ant </ code>) 에는 이 디렉토리에 있는 응용 프로그램의 Web 애플리케이션 아카이브 파일의 정확한 이미지가 포함되어 있습니다.
    Tomcat은 당신이 <code> $CATALINA_BASE/webapps </code> 디렉토리 또는 <em> 설치 </em> 는 그것을 "관리자"를 통해 웹 응용 프로그램으로 복사하거나 이러한 압축을 푼 디렉토리에 응용 프로그램을 배포 할 수 있습니다.
    후자의 방식은 개발 시에 매우 유용하며, 그에 대한 설명을 하겠습니다.
    <br/><br/></li>
<li><strong>dist/</strong> - 당신의 <code> dist </code> 타겟을 실행하면 해당 디렉토리가 생성됩니다.
당신이 준비한 라이센스 정보 문서 및 README 파일을 포함하여 Web 응용 프로그램의 바이너리 디스트리뷰션의 정확한 이미지를 만듭니다.</li>
</ul>

<p>Note that these two directories should <strong>NOT</strong> be archived in
your source code control system, because they are deleted and recreated (from
scratch) as needed during development.  For that reason, you should not edit
any source files in these directories if you want to maintain a permanent
record of the changes, because the changes will be lost the next time that a
build is performed.</p>

  <subsection name="External Dependencies">

  <p>What do you do if your application requires JAR files (or other
  resources) from external projects or packages?  A common example is that
  you need to include a JDBC driver in your web application, in order to
  operate.</p>

  <p>Different developers take different approaches to this problem.
  Some will encourage checking a copy of the JAR files you depend on into
  the source code control archives for every application that requires those
  JAR files.  However, this can cause significant management issues when you
  use the same JAR in many applications - particular when faced with a need
  to upgrade to a different version of that JAR file.</p>

  <p>Therefore, this manual recommends that you <strong>NOT</strong> store
  a copy of the packages you depend on inside the source control archives
  of your applications.  Instead, the external dependencies should be
  integrated as part of the process of <strong>building</strong> your
  application.  In that way, you can always pick up the appropriate version
  of the JAR files from wherever your development system administrator has
  installed them, without having to worry about updating your application
  every time the version of the dependent JAR file is changed.</p>

  <p>In the example Ant <code>build.xml</code> file, we will demonstrate
  how to define <em>build properties</em> that let you configure the locations
  of the files to be copied, without having to modify <code>build.xml</code>
  when these files change.  The build properties used by a particular
  developer can be customized on a per-application basis, or defaulted to
  "standard" build properties stored in the developer's home directory.</p>

  <p>In many cases, your development system administrator will have already
  installed the required JAR files into the <code>lib</code> directory of Tomcat.
  If this has been done, you need
  to take no actions at all - the example <code>build.xml</code> file
  automatically constructs a compile classpath that includes these files.</p>

  </subsection>

</section>


<section name="Source Code Control">

<p>As mentioned earlier, it is highly recommended that you place all of the
source files that comprise your application under the management of a
source code control system like the Concurrent Version System (CVS).  If you
elect to do this, every directory and file in the source hierarchy should be
registered and saved -- but none of the generated files.  If you register
binary format files (such as images or JAR libraries), be sure to indicate
this to your source code control system.</p>

<p>We recommended (in the previous section) that you should not store the
contents of the <code>build/</code> and <code>dist/</code> directories
created by your development process in the source code control system.  An
easy way to tell CVS to ignore these directories is to create a file named
<code>.cvsignore</code> (note the leading period) in your top-level source
directory, with the following contents:</p>
<source>
build
dist
build.properties
</source>

<p>The reason for mentioning <code>build.properties</code> here will be
explained in the <a href="processes.html">Processes</a> section.</p>

<p>Detailed instructions for your source code control environment are beyond
the scope of this manual.  However, the following steps are followed when
using a command-line CVS client:</p>
<ul>
<li>To refresh the state of your source code to that stored in the
    the source repository, go to your project source directory, and
    execute <code>cvs update -dP</code>.
    <br/><br/></li>
<li>When you create a new subdirectory in the source code hierarchy, register
    it in CVS with a command like <code>cvs add {subdirname}</code>.
    <br/><br/></li>
<li>When you first create a new source code file, navigate to the directory
    that contains it, and register the new file with a command like
    <code>cvs add {filename}</code>.
    <br/><br/></li>
<li>If you no longer need a particular source code file, navigate to the
    containing directory and remove the file.  Then, deregister it in CVS
    with a command like <code>cvs remove {filename}</code>.
    <br/><br/></li>
<li>While you are creating, modifying, and deleting source files, changes
    are not yet reflected in the server repository.  To save your changes in
    their current state, go to the project source directory
    and execute <code>cvs commit</code>.  You will be asked to write a brief
    description of the changes you have just completed, which will be stored
    with the new version of any updated source file.</li>
</ul>

<p>CVS, like other source code control systems, has many additional features
(such as the ability to tag the files that made up a particular release, and
support for multiple development branches that can later be merged).  See the
links and references in the <a href="introduction.html">Introduction</a> for
more information.</p>

</section>


<section name="BUILD.XML Configuration File">

<p>We will be using the <strong>ant</strong> tool to manage the compilation of
our Java source code files, and creation of the deployment hierarchy.  Ant
operates under the control of a build file, normally called
<code>build.xml</code>, that defines the processing steps required.  This
file is stored in the top-level directory of your source code hierarchy, and
should be checked in to your source code control system.</p>

<p>Like a Makefile, the <code>build.xml</code> file provides several
"targets" that support optional development activities (such as creating
the associated Javadoc documentation, erasing the deployment home directory
so you can build your project from scratch, or creating the web application
archive file so you can distribute your application.  A well-constructed
<code>build.xml</code> file will contain internal documentation describing
the targets that are designed for use by the developer, versus those targets
used internally.  To ask Ant to display the project documentation, change to
the directory containing the <code>build.xml</code> file and type:</p>
<source>
ant -projecthelp
</source>

<p>To give you a head start, a <a href="build.xml.txt">basic build.xml file</a>
is provided that you can customize and install in the project source directory
for your application.  This file includes comments that describe the various
targets that can be executed.  Briefly, the following targets are generally
provided:</p>
<ul>
<li><strong>clean</strong> - This target deletes any existing
    <code>build</code> and <code>dist</code> directories, so that they
    can be reconstructed from scratch.  This allows you to guarantee that
    you have not made source code modifications that will result in
    problems at runtime due to not recompiling all affected classes.
    <br/><br/></li>
<li><strong>compile</strong> - This target is used to compile any source code
    that has been changed since the last time compilation took place.  The
    resulting class files are created in the <code>WEB-INF/classes</code>
    subdirectory of your <code>build</code> directory, exactly where the
    structure of a web application requires them to be.  Because
    this command is executed so often during development, it is normally
    made the "default" target so that a simple <code>ant</code> command will
    execute it.
    <br/><br/></li>
<li><strong>all</strong> - This target is a short cut for running the
    <code>clean</code> target, followed by the <code>compile</code> target.
    Thus, it guarantees that you will recompile the entire application, to
    ensure that you have not unknowingly introduced any incompatible changes.
    <br/><br/></li>
<li><strong>javadoc</strong> - This target creates Javadoc API documentation
    for the Java classes in this web application.  The example
    <code>build.xml</code> file assumes you want to include the API
    documentation with your app distribution, so it generates the docs
    in a subdirectory of the <code>dist</code> directory.  Because you normally
    do not need to generate the Javadocs on every compilation, this target is
    usually a dependency of the <code>dist</code> target, but not of the
    <code>compile</code> target.
    <br/><br/></li>
<li><strong>dist</strong> - This target creates a distribution directory for
    your application, including any required documentation, the Javadocs for
    your Java classes, and a web application archive (WAR) file that will be
    delivered to system administrators who wish to install your application.
    Because this target also depends on the <code>deploy</code> target, the
    web application archive will have also picked up any external dependencies
    that were included at deployment time.</li>
</ul>

<p>For interactive development and testing of your web application using
Tomcat, the following additional targets are defined:</p>
<ul>
<li><strong>install</strong> - Tell the currently running Tomcat to make
    the application you are developing immediately available for execution
    and testing.  This action does not require Tomcat to be restarted, but
    it is also not remembered after Tomcat is restarted the next time.
    <br/><br/></li>
<li><strong>reload</strong> - Once the application is installed, you can
    continue to make changes and recompile using the <code>compile</code>
    target.  Tomcat will automatically recognize changes made to JSP pages,
    but not to servlet or JavaBean classes - this command will tell Tomcat
    to restart the currently installed application so that such changes are
    recognized.
    <br/><br/></li>
<li><strong>remove</strong> - When you have completed your development and
    testing activities, you can optionally tell Tomcat to remove this
    application from service.
    </li>
</ul>

<p>Using the development and testing targets requires some additional
one-time setup that is described on the next page.</p>

</section>


</body>
</document>
